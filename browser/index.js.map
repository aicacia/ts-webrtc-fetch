{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/HTTP.ts","../src/createWebRTCFetch.ts","../src/createWebRTCServer.ts"],"sourcesContent":["import { MAX_INT } from \"@aicacia/rand\";\n\nexport const DEFAULT_MAX_MESSAGE_SIZE = 16384;\nexport const DEFAULT_TIMEOUT_MS = 60_000;\nexport const DEFAULT_BUFFER_SIZE = 4096;\n\nexport function concatUint8Array(a: Uint8Array, b: Uint8Array) {\n\tconst bytes = new Uint8Array(a.byteLength + b.byteLength);\n\tbytes.set(a);\n\tbytes.set(b, a.byteLength);\n\treturn bytes;\n}\n\nexport function writeToUint8Array(\n\tbuffer: Uint8Array,\n\toffset: number,\n\tchunk: Uint8Array,\n): Uint8Array {\n\tif (chunk.byteLength >= buffer.byteLength - offset) {\n\t\tconst newBuffer = new Uint8Array(buffer.byteLength * 2);\n\t\tnewBuffer.set(buffer);\n\t\tnewBuffer.set(chunk, offset);\n\t\treturn newBuffer;\n\t}\n\tbuffer.set(chunk, offset);\n\treturn buffer;\n}\n\nexport function randomUInt32() {\n\treturn (Math.random() * MAX_INT) | 0;\n}\n\nexport function writableStreamFromChannel(\n\tchannel: RTCDataChannel,\n\tidBytes: Uint8Array,\n\tmaxChannelMessageSize: number,\n) {\n\treturn new WritableStream({\n\t\twrite(chunk: Uint8Array) {\n\t\t\twrite(channel, concatUint8Array(idBytes, chunk), maxChannelMessageSize);\n\t\t},\n\t});\n}\n\nexport function write(\n\tchannel: RTCDataChannel,\n\tchunk: Uint8Array,\n\tmaxChannelMessageSize: number,\n) {\n\tif (chunk.byteLength < maxChannelMessageSize) {\n\t\tchannel.send(chunk);\n\t} else {\n\t\tlet offset = 0;\n\t\twhile (offset < chunk.byteLength) {\n\t\t\tconst length = Math.min(maxChannelMessageSize, chunk.byteLength - offset);\n\t\t\tchannel.send(chunk.slice(offset, offset + length));\n\t\t\toffset += length;\n\t\t}\n\t}\n}\n\nexport function bufferedWritableStream(\n\twritableStream: WritableStream<Uint8Array>,\n\tbufferSize = DEFAULT_BUFFER_SIZE,\n): WritableStream<Uint8Array> {\n\tconst buffer = new Uint8Array(bufferSize);\n\tlet bufferOffset = 0;\n\tconst writer = writableStream.getWriter();\n\tasync function write(chunk: Uint8Array) {\n\t\tif (chunk.byteLength > buffer.byteLength - bufferOffset) {\n\t\t\tawait flush();\n\t\t}\n\t\tif (chunk.byteLength >= buffer.byteLength) {\n\t\t\tawait writer.write(chunk);\n\t\t} else {\n\t\t\tbuffer.set(chunk, bufferOffset);\n\t\t\tbufferOffset += chunk.byteLength;\n\t\t}\n\t}\n\tasync function flush() {\n\t\tif (bufferOffset > 0) {\n\t\t\tawait writer.write(buffer.slice(0, bufferOffset));\n\t\t\tbufferOffset = 0;\n\t\t}\n\t}\n\treturn new WritableStream({\n\t\twrite,\n\t\tasync close() {\n\t\t\tawait flush();\n\t\t\tawait writer.close();\n\t\t},\n\t});\n}\n\nexport async function readAll(\n\treader: ReadableStreamDefaultReader<Uint8Array>,\n): Promise<Uint8Array> {\n\ttry {\n\t\tconst { done, value: bytes } = await reader.read();\n\t\tif (done) {\n\t\t\treturn new Uint8Array();\n\t\t}\n\t\tlet result = bytes;\n\t\twhile (true) {\n\t\t\tconst { done, value: bytes } = await reader.read();\n\t\t\tif (done) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult = concatUint8Array(result, bytes);\n\t\t}\n\t\treturn result;\n\t} finally {\n\t\treader.releaseLock();\n\t}\n}\n","import {\n\tDEFAULT_BUFFER_SIZE,\n\tDEFAULT_MAX_MESSAGE_SIZE,\n\treadAll,\n\twriteToUint8Array,\n} from \"./utils\";\n\nconst HEADER_REGEX = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\nconst HEADER_CONTINUE_REGEX = /^[ \\t]+(.*[^ \\t])/;\nconst REQUEST_REGEX = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\nconst RESPONSE_REGEX = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\n\nconst NEWLINE = \"\\n\".charCodeAt(0);\nconst RETURN = \"\\r\".charCodeAt(0);\n\nconst TEXT_ENCODER = new TextEncoder();\nconst TEXT_DECODER = new TextDecoder();\n\nexport class HTTPRequest extends Request {\n\tconstructor(input: RequestInfo | URL, init?: RequestInit) {\n\t\tconst headersInit = init?.headers;\n\t\tsuper(input, init);\n\t\tif (headersInit) {\n\t\t\tconst headers = new Headers(headersInit);\n\t\t\tObject.defineProperty(this, \"headers\", {\n\t\t\t\tvalue: headers,\n\t\t\t\twritable: false,\n\t\t\t});\n\t\t}\n\t}\n}\n\nexport async function parseHTTPRequest(\n\treader: ReadableStreamDefaultReader<Uint8Array>,\n): Promise<Request> {\n\tconst textReader = createTextReader(reader);\n\tconst [method, url] = await readRequestStartLine(textReader);\n\tconst [headers, chunked, contentLength] = await readHeaders(textReader);\n\tconst body = streamBody(textReader, chunked, contentLength);\n\treturn new HTTPRequest(url, {\n\t\tmethod,\n\t\theaders,\n\t\tbody,\n\t\tmode: \"same-origin\",\n\t\tcredentials: \"include\",\n\t\t// @ts-expect-error\n\t\tduplex: \"half\",\n\t});\n}\n\nexport async function parseHTTPResponse(\n\treader: ReadableStreamDefaultReader<Uint8Array>,\n) {\n\tconst textReader = createTextReader(reader);\n\tconst [statusCode, statusText] = await readResponseStartLine(textReader);\n\tconst [headers, chunked, contentLength] = await readHeaders(textReader);\n\tconst body = streamBody(textReader, chunked, contentLength);\n\treturn new Response(body, {\n\t\tstatus: statusCode,\n\t\tstatusText: statusText,\n\t\theaders,\n\t});\n}\n\nexport async function writeHTTPRequestOrResponse(\n\twritableStream: WritableStream<Uint8Array>,\n\trequestOrResponse: Request | Response,\n) {\n\tconst writer = writableStream.getWriter();\n\tconst [request, response] =\n\t\trequestOrResponse instanceof Request\n\t\t\t? [requestOrResponse, null]\n\t\t\t: [null, requestOrResponse];\n\tif (request) {\n\t\tawait writer.write(\n\t\t\tTEXT_ENCODER.encode(`${request.method} ${request.url} HTTP/1.1\\r\\n`),\n\t\t);\n\t} else {\n\t\tawait writer.write(\n\t\t\tTEXT_ENCODER.encode(\n\t\t\t\t`HTTP/1.1 ${response.status} ${response.statusText}\\r\\n`,\n\t\t\t),\n\t\t);\n\t}\n\tconst headers = requestOrResponse.headers as Headers & {\n\t\tentries(): IterableIterator<[string, string]>;\n\t};\n\tlet contentLength = 0;\n\tlet chunked = false;\n\tif (requestOrResponse.body) {\n\t\tcontentLength = Number.parseInt(headers.get(\"Content-Length\") || \"0\", 10);\n\t\tchunked = headers.get(\"Transfer-Encoding\")?.toLowerCase() === \"chunked\";\n\t}\n\tfor (const [key, value] of headers.entries()) {\n\t\tawait writer.write(TEXT_ENCODER.encode(`${key}: ${value}\\r\\n`));\n\t}\n\tif (requestOrResponse.body) {\n\t\tif (request) {\n\t\t\tconst body = await readAll(requestOrResponse.body.getReader());\n\n\t\t\tawait writer.write(\n\t\t\t\tTEXT_ENCODER.encode(`Content-Length: ${body.byteLength}\\r\\n\\r\\n`),\n\t\t\t);\n\t\t\tawait writer.write(body);\n\n\t\t\twriter.releaseLock();\n\t\t\twritableStream.close();\n\t\t} else {\n\t\t\tawait writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n\t\t\twriter.releaseLock();\n\n\t\t\tawait streamBody(\n\t\t\t\tcreateTextReader(requestOrResponse.body.getReader()),\n\t\t\t\tchunked,\n\t\t\t\tcontentLength,\n\t\t\t)?.pipeTo(writableStream);\n\t\t}\n\t} else {\n\t\tawait writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n\t}\n}\n\nasync function readRequestStartLine(\n\treader: TextReader,\n): Promise<\n\t[method: string, url: string, versionMajor: number, versionMinor: number]\n> {\n\tconst { done, value: startLine } = await reader.readLine();\n\tif (done) {\n\t\tthrow new Error(\"Unexpected end of request\");\n\t}\n\tconst match = REQUEST_REGEX.exec(startLine);\n\tif (!match) {\n\t\tthrow new Error(`Invalid request line: ${startLine}`);\n\t}\n\treturn [match[1], match[2], +match[3], +match[4]];\n}\n\nasync function readResponseStartLine(\n\treader: TextReader,\n): Promise<\n\t[\n\t\tstatusCode: number,\n\t\tstatusText: string,\n\t\tversionMajor: number,\n\t\tversionMinor: number,\n\t]\n> {\n\tconst { done, value: startLine } = await reader.readLine();\n\tif (done) {\n\t\tthrow new Error(\"Unexpected end of request\");\n\t}\n\tconst match = RESPONSE_REGEX.exec(startLine);\n\tif (!match) {\n\t\tthrow new Error(`Invalid response line: ${startLine}`);\n\t}\n\treturn [+match[3], match[4], +match[1], +match[2]];\n}\n\nasync function readHeaders(\n\treader: TextReader,\n): Promise<[headers: Headers, chunked: boolean, contentLength: number]> {\n\tconst headers = new Headers();\n\tlet chunked = false;\n\tlet contentLength = 0;\n\twhile (true) {\n\t\tconst { done, value: line } = await reader.readLine();\n\t\tif (done) {\n\t\t\tthrow new Error(\"Unexpected end of headers\");\n\t\t}\n\t\tif (line === \"\") {\n\t\t\tbreak;\n\t\t}\n\t\tconst match = HEADER_REGEX.exec(line);\n\t\tif (!match) {\n\t\t\tthrow new Error(`Invalid header line: ${line}`);\n\t\t}\n\t\tlet value = match[2];\n\t\twhile (true) {\n\t\t\tconst continueMatch = HEADER_CONTINUE_REGEX.exec(value);\n\t\t\tif (!continueMatch) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvalue = continueMatch[1];\n\t\t}\n\t\tconst key = match[1].toLowerCase();\n\t\tif (key === \"transfer-encoding\" && value.toLowerCase() === \"chunked\") {\n\t\t\tchunked = true;\n\t\t} else if (key === \"content-length\") {\n\t\t\tcontentLength = +value;\n\t\t}\n\t\theaders.append(match[1], value);\n\t}\n\treturn [headers, chunked, contentLength];\n}\n\nfunction streamBody(\n\treader: TextReader,\n\tchunked: boolean,\n\tcontentLength: number,\n): ReadableStream<Uint8Array> | null {\n\tif (!chunked && contentLength === 0) {\n\t\treturn null;\n\t}\n\tconst stream = new TransformStream<Uint8Array, Uint8Array>();\n\tstreamBodyFromReaderToWriter(reader, stream.writable, chunked, contentLength);\n\treturn stream.readable;\n}\n\nasync function streamBodyFromReaderToWriter(\n\treader: TextReader,\n\twritableStream: WritableStream<Uint8Array>,\n\tchunked: boolean,\n\tcontentLength: number,\n) {\n\tconst writer = writableStream.getWriter();\n\ttry {\n\t\tif (chunked) {\n\t\t\twhile (true) {\n\t\t\t\tconst { done, value: line } = await reader.readLine();\n\t\t\t\tif (done) {\n\t\t\t\t\tthrow new Error(\"Unexpected end of stream\");\n\t\t\t\t}\n\t\t\t\tif (HEADER_REGEX.exec(line)) {\n\t\t\t\t\tawait reader.readLine();\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tconst chunkSize = Number.parseInt(line, 16);\n\t\t\t\tif (!chunkSize) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tlet bytesLeft = chunkSize;\n\t\t\t\twhile (bytesLeft > 0) {\n\t\t\t\t\tconst { done, value: bytes } = await reader.read(chunkSize);\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\tthrow new Error(\"Unexpected end of stream\");\n\t\t\t\t\t}\n\t\t\t\t\tbytesLeft -= bytes.byteLength;\n\t\t\t\t\tawait writer.write(bytes);\n\t\t\t\t}\n\t\t\t\tawait reader.readLine();\n\t\t\t}\n\t\t} else {\n\t\t\tlet bytesLeft = contentLength;\n\t\t\twhile (bytesLeft > 0) {\n\t\t\t\tconst { done, value: bytes } = await reader.read(bytesLeft);\n\t\t\t\tif (done) {\n\t\t\t\t\tthrow new Error(\"Unexpected end of stream\");\n\t\t\t\t}\n\t\t\t\tbytesLeft -= bytes.byteLength;\n\t\t\t\tawait writer.write(bytes);\n\t\t\t}\n\t\t}\n\t} finally {\n\t\treader.releaseLock();\n\t\twriter.releaseLock();\n\t\twritableStream.close();\n\t}\n}\n\ntype TextReader = ReturnType<typeof createTextReader>;\n\nfunction createTextReader(\n\treader: ReadableStreamDefaultReader<Uint8Array>,\n\tbufferSize = DEFAULT_BUFFER_SIZE,\n) {\n\tlet buffer = new Uint8Array(bufferSize);\n\tlet bufferOffset = 0;\n\tlet bufferLength = 0;\n\tlet doneReading = false;\n\n\tasync function tryFillTo(offset: number) {\n\t\tif (doneReading) {\n\t\t\treturn offset < bufferLength;\n\t\t}\n\t\twhile (offset > bufferLength) {\n\t\t\tconst { done, value: bytes } = await reader.read();\n\t\t\tif (done) {\n\t\t\t\tdoneReading = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tbuffer = writeToUint8Array(buffer, bufferLength, bytes);\n\t\t\tbufferLength += bytes.byteLength;\n\t\t}\n\t\treturn offset < bufferLength;\n\t}\n\n\tasync function readLine(): Promise<ReadableStreamReadResult<string>> {\n\t\tlet index = bufferOffset;\n\t\tlet hasData = true;\n\t\twhile (hasData) {\n\t\t\tif (buffer[index] === RETURN && buffer[index + 1] === NEWLINE) {\n\t\t\t\tconst line = TEXT_DECODER.decode(buffer.slice(bufferOffset, index));\n\t\t\t\tbufferOffset = index + 2;\n\t\t\t\treturn { done: false, value: line };\n\t\t\t}\n\t\t\tindex++;\n\t\t\tif (index >= bufferLength) {\n\t\t\t\thasData = await tryFillTo(index);\n\t\t\t}\n\t\t}\n\t\treturn { done: true };\n\t}\n\n\tasync function read(\n\t\tbyteCount: number,\n\t): Promise<ReadableStreamReadResult<Uint8Array>> {\n\t\tconst byteLength = bufferOffset + byteCount;\n\t\tawait tryFillTo(byteLength);\n\t\tconst maxBytesToRead = Math.min(bufferLength - bufferOffset, byteCount);\n\t\tif (maxBytesToRead === 0) {\n\t\t\treturn { done: true };\n\t\t}\n\t\tconst bytes = buffer.slice(bufferOffset, bufferOffset + maxBytesToRead);\n\t\tbufferOffset += maxBytesToRead;\n\t\treturn { done: false, value: bytes };\n\t}\n\n\tfunction releaseLock() {\n\t\treader.releaseLock();\n\t}\n\n\treturn {\n\t\treadLine,\n\t\tread,\n\t\treleaseLock,\n\t};\n}\n","import { bytesToInteger, integerToBytes } from \"@aicacia/hash\";\nimport {\n\tbufferedWritableStream,\n\tDEFAULT_MAX_MESSAGE_SIZE,\n\trandomUInt32,\n\twritableStreamFromChannel,\n} from \"./utils\";\nimport {\n\tHTTPRequest,\n\tparseHTTPResponse,\n\twriteHTTPRequestOrResponse,\n} from \"./HTTP\";\n\ntype Fetch = typeof fetch;\n\nexport type WebRTCFetch = Fetch & {\n\tdestroy(): void;\n};\n\ntype WebRTCConnection = {\n\tidBytes: Uint8Array;\n\tstream: TransformStream;\n\twriter: WritableStreamDefaultWriter<Uint8Array>;\n};\n\nexport function createWebRTCFetch(channel: RTCDataChannel): WebRTCFetch {\n\tconst connections = new Map<number, WebRTCConnection>();\n\n\tfunction createWebRTCConnection() {\n\t\tlet connectionId = randomUInt32();\n\t\twhile (connections.has(connectionId)) {\n\t\t\tconnectionId = randomUInt32();\n\t\t}\n\t\tconst idBytes = integerToBytes(new Uint8Array(4), connectionId);\n\t\tconst stream = new TransformStream();\n\t\tconst connection = {\n\t\t\tidBytes,\n\t\t\tstream,\n\t\t\twriter: stream.writable.getWriter(),\n\t\t};\n\t\tconnections.set(connectionId, connection);\n\t\treturn connection;\n\t}\n\n\tasync function onData(connectionId: number, chunk: Uint8Array) {\n\t\tconst connection = connections.get(connectionId);\n\t\tif (!connection) {\n\t\t\tthrow new Error(`No connection found for id: ${connectionId}`);\n\t\t}\n\t\tawait connection.writer.write(chunk);\n\t}\n\n\tasync function onMessage(event: MessageEvent) {\n\t\tconst chunk = new Uint8Array(event.data);\n\t\tconst connectionId = bytesToInteger(chunk);\n\t\tawait onData(connectionId, chunk.slice(4));\n\t}\n\tchannel.addEventListener(\"message\", onMessage);\n\n\tconst fetch: WebRTCFetch = (input, init) => {\n\t\treturn new Promise<Response>((resolve, reject) => {\n\t\t\tconst request = new HTTPRequest(input, init);\n\t\t\tconst connection = createWebRTCConnection();\n\t\t\tconst writableStream = bufferedWritableStream(\n\t\t\t\twritableStreamFromChannel(\n\t\t\t\t\tchannel,\n\t\t\t\t\tconnection.idBytes,\n\t\t\t\t\tDEFAULT_MAX_MESSAGE_SIZE,\n\t\t\t\t),\n\t\t\t);\n\t\t\twriteHTTPRequestOrResponse(writableStream, request)\n\t\t\t\t.then(() =>\n\t\t\t\t\tparseHTTPResponse(connection.stream.readable.getReader()).then(\n\t\t\t\t\t\tresolve,\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.catch(reject);\n\t\t});\n\t};\n\n\tfetch.destroy = () => channel.removeEventListener(\"message\", onMessage);\n\n\treturn fetch;\n}\n","import { bytesToInteger, integerToBytes } from \"@aicacia/hash\";\nimport { parseHTTPRequest, writeHTTPRequestOrResponse } from \"./HTTP\";\nimport {\n\tbufferedWritableStream,\n\tDEFAULT_MAX_MESSAGE_SIZE,\n\twritableStreamFromChannel,\n} from \"./utils\";\n\ninterface WebRTCConnection {\n\tstream: TransformStream<Uint8Array, Uint8Array>;\n\twriter: WritableStreamDefaultWriter<Uint8Array>;\n}\n\nfunction createWebRTCConnection(): WebRTCConnection {\n\tconst stream = new TransformStream<Uint8Array>();\n\treturn {\n\t\tstream,\n\t\twriter: stream.writable.getWriter(),\n\t};\n}\n\nexport function createWebRTCServer(\n\tchannel: RTCDataChannel,\n\thandler: (request: Request) => Promise<Response> | Response,\n) {\n\tconst connections = new Map<number, WebRTCConnection>();\n\n\tasync function handle(connectionId: number, connection: WebRTCConnection) {\n\t\tconst request = await parseHTTPRequest(\n\t\t\tconnection.stream.readable.getReader(),\n\t\t);\n\t\tconst response = await handler(request);\n\t\tconst writableStream = bufferedWritableStream(\n\t\t\twritableStreamFromChannel(\n\t\t\t\tchannel,\n\t\t\t\tintegerToBytes(new Uint8Array(4), connectionId),\n\t\t\t\tDEFAULT_MAX_MESSAGE_SIZE,\n\t\t\t),\n\t\t);\n\t\tawait writeHTTPRequestOrResponse(writableStream, response);\n\t}\n\n\tasync function onData(connectionId: number, chunk: Uint8Array) {\n\t\tlet connection = connections.get(connectionId);\n\t\tif (!connection) {\n\t\t\tconnection = createWebRTCConnection();\n\t\t\tconnections.set(connectionId, connection);\n\t\t\thandle(connectionId, connection);\n\t\t}\n\t\tawait connection.writer.write(chunk);\n\t}\n\n\tasync function onMessage(event: MessageEvent) {\n\t\tconst chunk = new Uint8Array(event.data);\n\t\tconst connectionId = bytesToInteger(chunk);\n\t\tawait onData(connectionId, chunk.slice(4));\n\t}\n\tchannel.addEventListener(\"message\", onMessage);\n\n\treturn () => {\n\t\tchannel.removeEventListener(\"message\", onMessage);\n\t};\n}\n"],"names":["DEFAULT_BUFFER_SIZE","concatUint8Array","a","b","bytes","Uint8Array","byteLength","set","writeToUint8Array","buffer","offset","chunk","newBuffer","randomUInt32","Math","random","MAX_INT","writableStreamFromChannel","channel","idBytes","maxChannelMessageSize","WritableStream","write","send","length","min","slice","bufferedWritableStream","writableStream","bufferSize","bufferOffset","writer","getWriter","async","flush","close","HEADER_REGEX","HEADER_CONTINUE_REGEX","REQUEST_REGEX","RESPONSE_REGEX","NEWLINE","charCodeAt","RETURN","TEXT_ENCODER","TextEncoder","TEXT_DECODER","TextDecoder","HTTPRequest","Request","constructor","input","init","headersInit","headers","super","Headers","Object","defineProperty","this","value","writable","parseHTTPRequest","reader","textReader","createTextReader","method","url","done","startLine","readLine","Error","match","exec","readRequestStartLine","chunked","contentLength","readHeaders","body","streamBody","mode","credentials","duplex","parseHTTPResponse","statusCode","statusText","readResponseStartLine","Response","status","writeHTTPRequestOrResponse","requestOrResponse","request","response","encode","Number","parseInt","get","toLowerCase","key","entries","read","result","releaseLock","readAll","getReader","pipeTo","line","continueMatch","append","stream","TransformStream","chunkSize","bytesLeft","streamBodyFromReaderToWriter","readable","bufferLength","doneReading","tryFillTo","index","hasData","decode","byteCount","maxBytesToRead","createWebRTCFetch","connections","Map","onMessage","event","data","connectionId","bytesToInteger","connection","onData","addEventListener","fetch","Promise","resolve","reject","has","integerToBytes","createWebRTCConnection","then","catch","destroy","removeEventListener","createWebRTCServer","handler","handle"],"mappings":"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"}