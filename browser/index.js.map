{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/HTTP.ts","../src/createWebRTCFetch.ts","../src/createWebRTCServer.ts"],"sourcesContent":["import { MAX_INT } from \"@aicacia/rand\";\n\nexport const DEFAULT_MAX_MESSAGE_SIZE = 16384;\nexport const DEFAULT_TIMEOUT_MS = 60_000;\nexport const DEFAULT_BUFFER_SIZE = 4096;\n\nexport function concatUint8Array(a: Uint8Array, b: Uint8Array) {\n\tconst bytes = new Uint8Array(a.byteLength + b.byteLength);\n\tbytes.set(a);\n\tbytes.set(b, a.byteLength);\n\treturn bytes;\n}\n\nexport function writeToUint8Array(\n\tbuffer: Uint8Array,\n\toffset: number,\n\tchunk: Uint8Array,\n): Uint8Array {\n\tif (chunk.byteLength >= buffer.byteLength - offset) {\n\t\tconst newBuffer = new Uint8Array(buffer.byteLength * 2);\n\t\tnewBuffer.set(buffer);\n\t\tnewBuffer.set(chunk, offset);\n\t\treturn newBuffer;\n\t}\n\tbuffer.set(chunk, offset);\n\treturn buffer;\n}\n\nexport function randomUInt32() {\n\treturn (Math.random() * MAX_INT) | 0;\n}\n\nexport function writableStreamFromChannel(\n\tchannel: RTCDataChannel,\n\tidBytes: Uint8Array,\n\tmaxChannelMessageSize: number,\n) {\n\treturn new WritableStream({\n\t\twrite(chunk: Uint8Array) {\n\t\t\tconsole.log(new TextDecoder().decode(chunk));\n\t\t\twrite(channel, concatUint8Array(idBytes, chunk), maxChannelMessageSize);\n\t\t},\n\t});\n}\n\nexport function write(\n\tchannel: RTCDataChannel,\n\tchunk: Uint8Array,\n\tmaxChannelMessageSize: number,\n) {\n\tif (chunk.byteLength < maxChannelMessageSize) {\n\t\tchannel.send(chunk);\n\t} else {\n\t\tlet offset = 0;\n\t\twhile (offset < chunk.byteLength) {\n\t\t\tconst length = Math.min(maxChannelMessageSize, chunk.byteLength - offset);\n\t\t\tchannel.send(chunk.slice(offset, offset + length));\n\t\t\toffset += length;\n\t\t}\n\t}\n}\n\nexport function bufferedWritableStream(\n\twritableStream: WritableStream<Uint8Array>,\n\tbufferSize = DEFAULT_BUFFER_SIZE,\n): WritableStream<Uint8Array> {\n\tconst buffer = new Uint8Array(bufferSize);\n\tlet bufferOffset = 0;\n\tconst writer = writableStream.getWriter();\n\tasync function write(chunk: Uint8Array) {\n\t\tif (chunk.byteLength > buffer.byteLength - bufferOffset) {\n\t\t\tawait flush();\n\t\t}\n\t\tif (chunk.byteLength >= buffer.byteLength) {\n\t\t\tawait writer.write(chunk);\n\t\t} else {\n\t\t\tbuffer.set(chunk, bufferOffset);\n\t\t\tbufferOffset += chunk.byteLength;\n\t\t}\n\t}\n\tasync function flush() {\n\t\tif (bufferOffset > 0) {\n\t\t\tawait writer.write(buffer.slice(0, bufferOffset));\n\t\t\tbufferOffset = 0;\n\t\t}\n\t}\n\treturn new WritableStream({\n\t\twrite,\n\t\tasync close() {\n\t\t\tawait flush();\n\t\t\tawait writer.close();\n\t\t},\n\t});\n}\n\nexport async function readAll(\n\treader: ReadableStreamDefaultReader<Uint8Array>,\n): Promise<Uint8Array> {\n\ttry {\n\t\tconst { done, value: bytes } = await reader.read();\n\t\tif (done) {\n\t\t\treturn new Uint8Array();\n\t\t}\n\t\tlet result = bytes;\n\t\twhile (true) {\n\t\t\tconst { done, value: bytes } = await reader.read();\n\t\t\tif (done) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult = concatUint8Array(result, bytes);\n\t\t}\n\t\treturn result;\n\t} finally {\n\t\treader.releaseLock();\n\t}\n}\n","import {\n  DEFAULT_BUFFER_SIZE,\n  DEFAULT_MAX_MESSAGE_SIZE,\n  readAll,\n  writeToUint8Array,\n} from \"./utils\";\n\nconst HEADER_REGEX = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\nconst HEADER_CONTINUE_REGEX = /^[ \\t]+(.*[^ \\t])/;\nconst REQUEST_REGEX = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\nconst RESPONSE_REGEX = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\n\nconst NEWLINE = \"\\n\".charCodeAt(0);\nconst RETURN = \"\\r\".charCodeAt(0);\n\nconst TEXT_ENCODER = new TextEncoder();\nconst TEXT_DECODER = new TextDecoder();\n\nexport class HTTPRequest extends Request {\n  constructor(input: RequestInfo | URL, init?: RequestInit) {\n    const headersInit = init?.headers;\n    super(input, init);\n    if (headersInit) {\n      const headers = new Headers(headersInit);\n      Object.defineProperty(this, \"headers\", {\n        value: headers,\n        writable: false,\n      });\n    }\n  }\n}\n\nexport async function parseHTTPRequest(\n  reader: ReadableStreamDefaultReader<Uint8Array>\n): Promise<Request> {\n  const textReader = createTextReader(reader);\n  const [method, url] = await readRequestStartLine(textReader);\n  const [headers, chunked, contentLength] = await readHeaders(textReader);\n  const body = streamBody(textReader, chunked, contentLength);\n  return new HTTPRequest(url, {\n    method,\n    headers,\n    body,\n    mode: \"same-origin\",\n    credentials: \"include\",\n    // @ts-expect-error\n    duplex: \"half\",\n  });\n}\n\nexport async function parseHTTPResponse(\n  reader: ReadableStreamDefaultReader<Uint8Array>\n) {\n  const textReader = createTextReader(reader);\n  const [statusCode, statusText] = await readResponseStartLine(textReader);\n  const [headers, chunked, contentLength] = await readHeaders(textReader);\n  const body = streamBody(textReader, chunked, contentLength);\n  return new Response(body, {\n    status: statusCode,\n    statusText: statusText,\n    headers,\n  });\n}\n\nexport async function writeHTTPRequestOrResponse(\n  writableStream: WritableStream<Uint8Array>,\n  requestOrResponse: Request | Response\n) {\n  const writer = writableStream.getWriter();\n  const [request, response] =\n    requestOrResponse instanceof Request\n      ? [requestOrResponse, null]\n      : [null, requestOrResponse];\n  if (request) {\n    await writer.write(\n      TEXT_ENCODER.encode(`${request.method} ${request.url} HTTP/1.1\\r\\n`)\n    );\n  } else {\n    await writer.write(\n      TEXT_ENCODER.encode(\n        `HTTP/1.1 ${response.status} ${response.statusText}\\r\\n`\n      )\n    );\n  }\n  const headers = requestOrResponse.headers as Headers & {\n    entries(): IterableIterator<[string, string]>;\n  };\n  let contentLength = 0;\n  let chunked = false;\n  if (requestOrResponse.body) {\n    contentLength = Number.parseInt(headers.get(\"Content-Length\") || \"0\", 10);\n    chunked = headers.get(\"Transfer-Encoding\")?.toLowerCase() === \"chunked\";\n  }\n  for (const [key, value] of headers.entries()) {\n    await writer.write(TEXT_ENCODER.encode(`${key}: ${value}\\r\\n`));\n  }\n  if (requestOrResponse.body) {\n    if (request) {\n      const body = await readAll(requestOrResponse.body.getReader());\n\n      await writer.write(\n        TEXT_ENCODER.encode(`Content-Length: ${body.byteLength}\\r\\n\\r\\n`)\n      );\n      await writer.write(body);\n\n      writer.releaseLock();\n      writableStream.close();\n    } else {\n      await writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n      writer.releaseLock();\n\n      await streamBody(\n        createTextReader(requestOrResponse.body.getReader()),\n        chunked,\n        contentLength\n      )?.pipeTo(writableStream);\n    }\n  } else {\n    await writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n  }\n}\n\nasync function readRequestStartLine(\n  reader: TextReader\n): Promise<\n  [method: string, url: string, versionMajor: number, versionMinor: number]\n> {\n  const { done, value: startLine } = await reader.readLine();\n  if (done) {\n    throw new Error(\"Unexpected end of request\");\n  }\n  const match = REQUEST_REGEX.exec(startLine);\n  if (!match) {\n    throw new Error(`Invalid request line: ${startLine}`);\n  }\n  return [match[1], match[2], +match[3], +match[4]];\n}\n\nasync function readResponseStartLine(\n  reader: TextReader\n): Promise<\n  [\n    statusCode: number,\n    statusText: string,\n    versionMajor: number,\n    versionMinor: number\n  ]\n> {\n  const { done, value: startLine } = await reader.readLine();\n  if (done) {\n    throw new Error(\"Unexpected end of request\");\n  }\n  const match = RESPONSE_REGEX.exec(startLine);\n  if (!match) {\n    throw new Error(`Invalid response line: ${startLine}`);\n  }\n  return [+match[3], match[4], +match[1], +match[2]];\n}\n\nasync function readHeaders(\n  reader: TextReader\n): Promise<[headers: Headers, chunked: boolean, contentLength: number]> {\n  const headers = new Headers();\n  let chunked = false;\n  let contentLength = 0;\n  while (true) {\n    const { done, value: line } = await reader.readLine();\n    if (done) {\n      throw new Error(\"Unexpected end of headers\");\n    }\n    if (line === \"\") {\n      break;\n    }\n    const match = HEADER_REGEX.exec(line);\n    if (!match) {\n      throw new Error(`Invalid header line: ${line}`);\n    }\n    let value = match[2];\n    while (true) {\n      const continueMatch = HEADER_CONTINUE_REGEX.exec(value);\n      if (!continueMatch) {\n        break;\n      }\n      value = continueMatch[1];\n    }\n    const key = match[1].toLowerCase();\n    if (key === \"transfer-encoding\" && value.toLowerCase() === \"chunked\") {\n      chunked = true;\n    } else if (key === \"content-length\") {\n      contentLength = +value;\n    }\n    headers.append(match[1], value);\n  }\n  return [headers, chunked, contentLength];\n}\n\nfunction streamBody(\n  reader: TextReader,\n  chunked: boolean,\n  contentLength: number\n): ReadableStream<Uint8Array> | null {\n  if (!chunked && contentLength === 0) {\n    return null;\n  }\n  const stream = new TransformStream<Uint8Array, Uint8Array>();\n  streamBodyFromReaderToWriter(reader, stream.writable, chunked, contentLength);\n  return stream.readable;\n}\n\nasync function streamBodyFromReaderToWriter(\n  reader: TextReader,\n  writableStream: WritableStream<Uint8Array>,\n  chunked: boolean,\n  contentLength: number\n) {\n  const writer = writableStream.getWriter();\n  try {\n    if (chunked) {\n      while (true) {\n        const { done, value: line } = await reader.readLine();\n        if (done) {\n          throw new Error(\"Unexpected end of stream\");\n        }\n        if (HEADER_REGEX.exec(line)) {\n          await reader.readLine();\n          break;\n        }\n        const chunkSize = Number.parseInt(line, 16);\n        if (!chunkSize) {\n          break;\n        }\n        let bytesLeft = chunkSize;\n        while (bytesLeft > 0) {\n          const { done, value: bytes } = await reader.read(chunkSize);\n          if (done) {\n            throw new Error(\"Unexpected end of stream\");\n          }\n          bytesLeft -= bytes.byteLength;\n          await writer.write(bytes);\n        }\n        await reader.readLine();\n      }\n    } else {\n      let bytesLeft = contentLength;\n      while (bytesLeft > 0) {\n        const { done, value: bytes } = await reader.read(bytesLeft);\n        if (done) {\n          throw new Error(\"Unexpected end of stream\");\n        }\n        bytesLeft -= bytes.byteLength;\n        await writer.write(bytes);\n      }\n    }\n  } finally {\n    reader.releaseLock();\n    writer.releaseLock();\n    writableStream.close();\n  }\n}\n\ntype TextReader = ReturnType<typeof createTextReader>;\n\nfunction createTextReader(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n  bufferSize = DEFAULT_BUFFER_SIZE\n) {\n  let buffer = new Uint8Array(bufferSize);\n  let bufferOffset = 0;\n  let bufferLength = 0;\n  let doneReading = false;\n\n  async function tryFillTo(offset: number) {\n    if (doneReading) {\n      return offset < bufferLength;\n    }\n    while (offset > bufferLength) {\n      const { done, value: bytes } = await reader.read();\n      if (done) {\n        doneReading = true;\n        break;\n      }\n      buffer = writeToUint8Array(buffer, bufferLength, bytes);\n      bufferLength += bytes.byteLength;\n    }\n    return offset < bufferLength;\n  }\n\n  async function readLine(): Promise<ReadableStreamReadResult<string>> {\n    let index = bufferOffset;\n    let hasData = true;\n    while (hasData) {\n      if (buffer[index] === RETURN && buffer[index + 1] === NEWLINE) {\n        const line = TEXT_DECODER.decode(buffer.slice(bufferOffset, index));\n        bufferOffset = index + 2;\n        return { done: false, value: line };\n      }\n      index++;\n      if (index >= bufferLength) {\n        hasData = await tryFillTo(index);\n      }\n    }\n    return { done: true };\n  }\n\n  async function read(\n    byteCount: number\n  ): Promise<ReadableStreamReadResult<Uint8Array>> {\n    const byteLength = bufferOffset + byteCount;\n    await tryFillTo(byteLength);\n    const maxBytesToRead = Math.min(bufferLength - bufferOffset, byteCount);\n    if (maxBytesToRead === 0) {\n      return { done: true };\n    }\n    const bytes = buffer.slice(bufferOffset, bufferOffset + maxBytesToRead);\n    bufferOffset += maxBytesToRead;\n    return { done: false, value: bytes };\n  }\n\n  function releaseLock() {\n    reader.releaseLock();\n  }\n\n  return {\n    readLine,\n    read,\n    releaseLock,\n  };\n}\n","import { bytesToInteger, integerToBytes } from \"@aicacia/hash\";\nimport {\n\tbufferedWritableStream,\n\tDEFAULT_MAX_MESSAGE_SIZE,\n\trandomUInt32,\n\twritableStreamFromChannel,\n} from \"./utils\";\nimport {\n\tHTTPRequest,\n\tparseHTTPResponse,\n\twriteHTTPRequestOrResponse,\n} from \"./HTTP\";\n\ntype Fetch = typeof fetch;\n\nexport type WebRTCFetch = Fetch & {\n\tdestroy(): void;\n};\n\ntype WebRTCConnection = {\n\tidBytes: Uint8Array;\n\tstream: TransformStream;\n\twriter: WritableStreamDefaultWriter<Uint8Array>;\n};\n\nexport function createWebRTCFetch(channel: RTCDataChannel): WebRTCFetch {\n\tconst connections = new Map<number, WebRTCConnection>();\n\n\tfunction createWebRTCConnection() {\n\t\tlet connectionId = randomUInt32();\n\t\twhile (connections.has(connectionId)) {\n\t\t\tconnectionId = randomUInt32();\n\t\t}\n\t\tconst idBytes = integerToBytes(new Uint8Array(4), connectionId);\n\t\tconst stream = new TransformStream();\n\t\tconst connection = {\n\t\t\tidBytes,\n\t\t\tstream,\n\t\t\twriter: stream.writable.getWriter(),\n\t\t};\n\t\tconnections.set(connectionId, connection);\n\t\treturn connection;\n\t}\n\n\tasync function onData(connectionId: number, chunk: Uint8Array) {\n\t\tconst connection = connections.get(connectionId);\n\t\tif (!connection) {\n\t\t\tthrow new Error(`No connection found for id: ${connectionId}`);\n\t\t}\n\t\tawait connection.writer.write(chunk);\n\t}\n\n\tasync function onMessage(event: MessageEvent) {\n\t\tconst chunk = new Uint8Array(event.data);\n\t\tconst connectionId = bytesToInteger(chunk);\n\t\tawait onData(connectionId, chunk.slice(4));\n\t}\n\tchannel.addEventListener(\"message\", onMessage);\n\n\tconst fetch: WebRTCFetch = (input, init) => {\n\t\treturn new Promise<Response>((resolve, reject) => {\n\t\t\tconst request = new HTTPRequest(input, init);\n\t\t\tconst connection = createWebRTCConnection();\n\t\t\tconst writableStream = bufferedWritableStream(\n\t\t\t\twritableStreamFromChannel(\n\t\t\t\t\tchannel,\n\t\t\t\t\tconnection.idBytes,\n\t\t\t\t\tDEFAULT_MAX_MESSAGE_SIZE,\n\t\t\t\t),\n\t\t\t);\n\t\t\twriteHTTPRequestOrResponse(writableStream, request)\n\t\t\t\t.then(() =>\n\t\t\t\t\tparseHTTPResponse(connection.stream.readable.getReader()).then(\n\t\t\t\t\t\tresolve,\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.catch(reject);\n\t\t});\n\t};\n\n\tfetch.destroy = () => channel.removeEventListener(\"message\", onMessage);\n\n\treturn fetch;\n}\n","import { bytesToInteger, integerToBytes } from \"@aicacia/hash\";\nimport { parseHTTPRequest, writeHTTPRequestOrResponse } from \"./HTTP\";\nimport {\n\tbufferedWritableStream,\n\tDEFAULT_MAX_MESSAGE_SIZE,\n\twritableStreamFromChannel,\n} from \"./utils\";\n\ninterface WebRTCConnection {\n\tstream: TransformStream<Uint8Array, Uint8Array>;\n\twriter: WritableStreamDefaultWriter<Uint8Array>;\n}\n\nfunction createWebRTCConnection(): WebRTCConnection {\n\tconst stream = new TransformStream<Uint8Array>();\n\treturn {\n\t\tstream,\n\t\twriter: stream.writable.getWriter(),\n\t};\n}\n\nexport function createWebRTCServer(\n\tchannel: RTCDataChannel,\n\thandler: (request: Request) => Promise<Response> | Response,\n) {\n\tconst connections = new Map<number, WebRTCConnection>();\n\n\tasync function handle(connectionId: number, connection: WebRTCConnection) {\n\t\tconst request = await parseHTTPRequest(\n\t\t\tconnection.stream.readable.getReader(),\n\t\t);\n\t\tconst response = await handler(request);\n\t\tconst writableStream = bufferedWritableStream(\n\t\t\twritableStreamFromChannel(\n\t\t\t\tchannel,\n\t\t\t\tintegerToBytes(new Uint8Array(4), connectionId),\n\t\t\t\tDEFAULT_MAX_MESSAGE_SIZE,\n\t\t\t),\n\t\t);\n\t\tawait writeHTTPRequestOrResponse(writableStream, response);\n\t}\n\n\tasync function onData(connectionId: number, chunk: Uint8Array) {\n\t\tlet connection = connections.get(connectionId);\n\t\tif (!connection) {\n\t\t\tconnection = createWebRTCConnection();\n\t\t\tconnections.set(connectionId, connection);\n\t\t\thandle(connectionId, connection);\n\t\t}\n\t\tawait connection.writer.write(chunk);\n\t}\n\n\tasync function onMessage(event: MessageEvent) {\n\t\tconst chunk = new Uint8Array(event.data);\n\t\tconst connectionId = bytesToInteger(chunk);\n\t\tawait onData(connectionId, chunk.slice(4));\n\t}\n\tchannel.addEventListener(\"message\", onMessage);\n\n\treturn () => {\n\t\tchannel.removeEventListener(\"message\", onMessage);\n\t};\n}\n"],"names":["DEFAULT_BUFFER_SIZE","concatUint8Array","a","b","bytes","Uint8Array","byteLength","set","writeToUint8Array","buffer","offset","chunk","newBuffer","randomUInt32","Math","random","MAX_INT","writableStreamFromChannel","channel","idBytes","maxChannelMessageSize","WritableStream","write","console","log","TextDecoder","decode","send","length","min","slice","bufferedWritableStream","writableStream","bufferSize","bufferOffset","writer","getWriter","async","flush","close","HEADER_REGEX","HEADER_CONTINUE_REGEX","REQUEST_REGEX","RESPONSE_REGEX","NEWLINE","charCodeAt","RETURN","TEXT_ENCODER","TextEncoder","TEXT_DECODER","HTTPRequest","Request","constructor","input","init","headersInit","headers","super","Headers","Object","defineProperty","this","value","writable","parseHTTPRequest","reader","textReader","createTextReader","method","url","done","startLine","readLine","Error","match","exec","readRequestStartLine","chunked","contentLength","readHeaders","body","streamBody","mode","credentials","duplex","parseHTTPResponse","statusCode","statusText","readResponseStartLine","Response","status","writeHTTPRequestOrResponse","requestOrResponse","request","response","encode","Number","parseInt","get","toLowerCase","key","entries","read","result","releaseLock","readAll","getReader","pipeTo","line","continueMatch","append","stream","TransformStream","chunkSize","bytesLeft","streamBodyFromReaderToWriter","readable","bufferLength","doneReading","tryFillTo","index","hasData","byteCount","maxBytesToRead","createWebRTCFetch","connections","Map","onMessage","event","data","connectionId","bytesToInteger","connection","onData","addEventListener","fetch","Promise","resolve","reject","has","integerToBytes","createWebRTCConnection","then","catch","destroy","removeEventListener","createWebRTCServer","handler","handle"],"mappings":"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"}