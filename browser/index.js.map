{"version":3,"file":"index.js","sources":["../src/utils.ts","../src/HTTP.ts","../src/createWebRTCFetch.ts","../src/createWebRTCServer.ts"],"sourcesContent":["import { MAX_INT } from \"@aicacia/rand\";\n\nexport const DEFAULT_MAX_MESSAGE_SIZE = 16384;\nexport const DEFAULT_TIMEOUT_MS = 60_000;\nexport const DEFAULT_BUFFER_SIZE = 4096;\n\nexport function concatUint8Array(a: Uint8Array, b: Uint8Array) {\n\tconst bytes = new Uint8Array(a.byteLength + b.byteLength);\n\tbytes.set(a);\n\tbytes.set(b, a.byteLength);\n\treturn bytes;\n}\n\nexport function writeToUint8Array(\n\tbuffer: Uint8Array,\n\toffset: number,\n\tchunk: Uint8Array,\n): Uint8Array {\n\tif (chunk.byteLength >= buffer.byteLength - offset) {\n\t\tconst newBuffer = new Uint8Array(buffer.byteLength * 2);\n\t\tnewBuffer.set(buffer);\n\t\tnewBuffer.set(chunk, offset);\n\t\treturn newBuffer;\n\t}\n\tbuffer.set(chunk, offset);\n\treturn buffer;\n}\n\nexport function randomUInt32() {\n\treturn (Math.random() * MAX_INT) | 0;\n}\n\nexport function writableStreamFromChannel(\n\tchannel: RTCDataChannel,\n\tidBytes: Uint8Array,\n\tmaxChannelMessageSize: number,\n) {\n\treturn new WritableStream({\n\t\twrite(chunk: Uint8Array) {\n\t\t\twrite(channel, concatUint8Array(idBytes, chunk), maxChannelMessageSize);\n\t\t},\n\t});\n}\n\nexport function write(\n\tchannel: RTCDataChannel,\n\tchunk: Uint8Array,\n\tmaxChannelMessageSize: number,\n) {\n\tif (chunk.byteLength < maxChannelMessageSize) {\n\t\tchannel.send(chunk);\n\t} else {\n\t\tlet offset = 0;\n\t\twhile (offset < chunk.byteLength) {\n\t\t\tconst length = Math.min(maxChannelMessageSize, chunk.byteLength - offset);\n\t\t\tchannel.send(chunk.slice(offset, offset + length));\n\t\t\toffset += length;\n\t\t}\n\t}\n}\n\nexport function bufferedWritableStream(\n\twritableStream: WritableStream<Uint8Array>,\n\tbufferSize = DEFAULT_BUFFER_SIZE,\n): WritableStream<Uint8Array> {\n\tconst buffer = new Uint8Array(bufferSize);\n\tlet bufferOffset = 0;\n\tconst writer = writableStream.getWriter();\n\tasync function write(chunk: Uint8Array) {\n\t\tif (chunk.byteLength > buffer.byteLength - bufferOffset) {\n\t\t\tawait flush();\n\t\t}\n\t\tif (chunk.byteLength >= buffer.byteLength) {\n\t\t\tawait writer.write(chunk);\n\t\t} else {\n\t\t\tbuffer.set(chunk, bufferOffset);\n\t\t\tbufferOffset += chunk.byteLength;\n\t\t}\n\t}\n\tasync function flush() {\n\t\tif (bufferOffset > 0) {\n\t\t\tawait writer.write(buffer.slice(0, bufferOffset));\n\t\t\tbufferOffset = 0;\n\t\t}\n\t}\n\treturn new WritableStream({\n\t\twrite,\n\t\tasync close() {\n\t\t\tawait flush();\n\t\t\tawait writer.close();\n\t\t},\n\t});\n}\n\nexport async function readAll(\n\treader: ReadableStreamDefaultReader<Uint8Array>,\n): Promise<Uint8Array> {\n\ttry {\n\t\tconst { done, value: bytes } = await reader.read();\n\t\tif (done) {\n\t\t\treturn new Uint8Array();\n\t\t}\n\t\tlet result = bytes;\n\t\twhile (true) {\n\t\t\tconst { done, value: bytes } = await reader.read();\n\t\t\tif (done) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tresult = concatUint8Array(result, bytes);\n\t\t}\n\t\treturn result;\n\t} finally {\n\t\treader.releaseLock();\n\t}\n}\n","import {\n  DEFAULT_BUFFER_SIZE,\n  DEFAULT_MAX_MESSAGE_SIZE,\n  readAll,\n  writeToUint8Array,\n} from \"./utils\";\n\nconst HEADER_REGEX = /^([^: \\t]+):[ \\t]*((?:.*[^ \\t])|)/;\nconst HEADER_CONTINUE_REGEX = /^[ \\t]+(.*[^ \\t])/;\nconst REQUEST_REGEX = /^([A-Z-]+) ([^ ]+) HTTP\\/(\\d)\\.(\\d)$/;\nconst RESPONSE_REGEX = /^HTTP\\/(\\d)\\.(\\d) (\\d{3}) ?(.*)$/;\n\nconst NEWLINE = \"\\n\".charCodeAt(0);\nconst RETURN = \"\\r\".charCodeAt(0);\n\nconst TEXT_ENCODER = new TextEncoder();\nconst TEXT_DECODER = new TextDecoder();\n\nexport class HTTPRequest extends Request {\n  constructor(input: RequestInfo | URL, init?: RequestInit) {\n    const headersInit = init?.headers;\n    super(input, init);\n    if (headersInit) {\n      const headers = new Headers(headersInit);\n      Object.defineProperty(this, \"headers\", {\n        value: headers,\n        writable: false,\n      });\n    }\n  }\n}\n\nexport async function parseHTTPRequest(\n  reader: ReadableStreamDefaultReader<Uint8Array>\n): Promise<Request> {\n  const textReader = createTextReader(reader);\n  const [method, url] = await readRequestStartLine(textReader);\n  const [headers, chunked, contentLength] = await readHeaders(textReader);\n  const body = streamBody(textReader, chunked, contentLength);\n  return new HTTPRequest(url, {\n    method,\n    headers,\n    body,\n    mode: \"same-origin\",\n    credentials: \"include\",\n    // @ts-expect-error\n    duplex: \"half\",\n  });\n}\n\nexport async function parseHTTPResponse(\n  reader: ReadableStreamDefaultReader<Uint8Array>\n) {\n  const textReader = createTextReader(reader);\n  const [statusCode, statusText] = await readResponseStartLine(textReader);\n  const [headers, chunked, contentLength] = await readHeaders(textReader);\n  const body = streamBody(textReader, chunked, contentLength);\n  return new Response(body, {\n    status: statusCode,\n    statusText: statusText,\n    headers,\n  });\n}\n\nexport async function writeHTTPRequestOrResponse(\n  writableStream: WritableStream<Uint8Array>,\n  requestOrResponse: Request | Response\n) {\n  const writer = writableStream.getWriter();\n  const [request, response] =\n    requestOrResponse instanceof Request\n      ? [requestOrResponse, null]\n      : [null, requestOrResponse];\n  if (request) {\n    await writer.write(\n      TEXT_ENCODER.encode(`${request.method} ${request.url} HTTP/1.1\\r\\n`)\n    );\n  } else {\n    await writer.write(\n      TEXT_ENCODER.encode(\n        `HTTP/1.1 ${response.status} ${response.statusText}\\r\\n`\n      )\n    );\n  }\n  const headers = requestOrResponse.headers as Headers & {\n    entries(): IterableIterator<[string, string]>;\n  };\n  let contentLength = 0;\n  let chunked = false;\n  if (requestOrResponse.body) {\n    contentLength = Number.parseInt(headers.get(\"Content-Length\") || \"0\", 10);\n    chunked = headers.get(\"Transfer-Encoding\")?.toLowerCase() === \"chunked\";\n  }\n  for (const [key, value] of headers.entries()) {\n    await writer.write(TEXT_ENCODER.encode(`${key}: ${value}\\r\\n`));\n  }\n  if (requestOrResponse.body) {\n    if (request) {\n      const body = await readAll(requestOrResponse.body.getReader());\n\n      await writer.write(\n        TEXT_ENCODER.encode(`Content-Length: ${body.byteLength}\\r\\n\\r\\n`)\n      );\n      await writer.write(body);\n\n      writer.releaseLock();\n      writableStream.close();\n    } else {\n      await writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n      writer.releaseLock();\n\n      await streamBody(\n        createTextReader(requestOrResponse.body.getReader()),\n        chunked,\n        contentLength\n      )?.pipeTo(writableStream);\n    }\n  } else {\n    await writer.write(TEXT_ENCODER.encode(\"\\r\\n\"));\n\n    writer.releaseLock();\n    writableStream.close();\n  }\n}\n\nasync function readRequestStartLine(\n  reader: TextReader\n): Promise<\n  [method: string, url: string, versionMajor: number, versionMinor: number]\n> {\n  const { done, value: startLine } = await reader.readLine();\n  if (done) {\n    throw new Error(\"Unexpected end of request\");\n  }\n  const match = REQUEST_REGEX.exec(startLine);\n  if (!match) {\n    throw new Error(`Invalid request line: ${startLine}`);\n  }\n  return [match[1], match[2], +match[3], +match[4]];\n}\n\nasync function readResponseStartLine(\n  reader: TextReader\n): Promise<\n  [\n    statusCode: number,\n    statusText: string,\n    versionMajor: number,\n    versionMinor: number\n  ]\n> {\n  const { done, value: startLine } = await reader.readLine();\n  if (done) {\n    throw new Error(\"Unexpected end of request\");\n  }\n  const match = RESPONSE_REGEX.exec(startLine);\n  if (!match) {\n    throw new Error(`Invalid response line: ${startLine}`);\n  }\n  return [+match[3], match[4], +match[1], +match[2]];\n}\n\nasync function readHeaders(\n  reader: TextReader\n): Promise<[headers: Headers, chunked: boolean, contentLength: number]> {\n  const headers = new Headers();\n  let chunked = false;\n  let contentLength = 0;\n  while (true) {\n    const { done, value: line } = await reader.readLine();\n    if (done) {\n      throw new Error(\"Unexpected end of headers\");\n    }\n    if (line === \"\") {\n      break;\n    }\n    const match = HEADER_REGEX.exec(line);\n    if (!match) {\n      throw new Error(`Invalid header line: ${line}`);\n    }\n    let value = match[2];\n    while (true) {\n      const continueMatch = HEADER_CONTINUE_REGEX.exec(value);\n      if (!continueMatch) {\n        break;\n      }\n      value = continueMatch[1];\n    }\n    const key = match[1].toLowerCase();\n    if (key === \"transfer-encoding\" && value.toLowerCase() === \"chunked\") {\n      chunked = true;\n    } else if (key === \"content-length\") {\n      contentLength = +value;\n    }\n    headers.append(match[1], value);\n  }\n  return [headers, chunked, contentLength];\n}\n\nfunction streamBody(\n  reader: TextReader,\n  chunked: boolean,\n  contentLength: number\n): ReadableStream<Uint8Array> | null {\n  if (!chunked && contentLength === 0) {\n    return null;\n  }\n  const stream = new TransformStream<Uint8Array, Uint8Array>();\n  streamBodyFromReaderToWriter(reader, stream.writable, chunked, contentLength);\n  return stream.readable;\n}\n\nasync function streamBodyFromReaderToWriter(\n  reader: TextReader,\n  writableStream: WritableStream<Uint8Array>,\n  chunked: boolean,\n  contentLength: number\n) {\n  const writer = writableStream.getWriter();\n  try {\n    if (chunked) {\n      while (true) {\n        const { done, value: line } = await reader.readLine();\n        if (done) {\n          throw new Error(\"Unexpected end of stream\");\n        }\n        if (HEADER_REGEX.exec(line)) {\n          await reader.readLine();\n          break;\n        }\n        const chunkSize = Number.parseInt(line, 16);\n        if (!chunkSize) {\n          break;\n        }\n        let bytesLeft = chunkSize;\n        while (bytesLeft > 0) {\n          const { done, value: bytes } = await reader.read(chunkSize);\n          if (done) {\n            throw new Error(\"Unexpected end of stream\");\n          }\n          bytesLeft -= bytes.byteLength;\n          await writer.write(bytes);\n        }\n        await reader.readLine();\n      }\n    } else {\n      let bytesLeft = contentLength;\n      while (bytesLeft > 0) {\n        const { done, value: bytes } = await reader.read(bytesLeft);\n        if (done) {\n          throw new Error(\"Unexpected end of stream\");\n        }\n        bytesLeft -= bytes.byteLength;\n        await writer.write(bytes);\n      }\n    }\n  } finally {\n    reader.releaseLock();\n    writer.releaseLock();\n    writableStream.close();\n  }\n}\n\ntype TextReader = ReturnType<typeof createTextReader>;\n\nfunction createTextReader(\n  reader: ReadableStreamDefaultReader<Uint8Array>,\n  bufferSize = DEFAULT_BUFFER_SIZE\n) {\n  let buffer = new Uint8Array(bufferSize);\n  let bufferOffset = 0;\n  let bufferLength = 0;\n  let doneReading = false;\n\n  async function tryFillTo(offset: number) {\n    if (doneReading) {\n      return offset < bufferLength;\n    }\n    while (offset > bufferLength) {\n      const { done, value: bytes } = await reader.read();\n      if (done) {\n        doneReading = true;\n        break;\n      }\n      buffer = writeToUint8Array(buffer, bufferLength, bytes);\n      bufferLength += bytes.byteLength;\n    }\n    return offset < bufferLength;\n  }\n\n  async function readLine(): Promise<ReadableStreamReadResult<string>> {\n    let index = bufferOffset;\n    let hasData = true;\n    while (hasData) {\n      if (buffer[index] === RETURN && buffer[index + 1] === NEWLINE) {\n        const line = TEXT_DECODER.decode(buffer.slice(bufferOffset, index));\n        bufferOffset = index + 2;\n        return { done: false, value: line };\n      }\n      index++;\n      if (index >= bufferLength) {\n        hasData = await tryFillTo(index);\n      }\n    }\n    return { done: true };\n  }\n\n  async function read(\n    byteCount: number\n  ): Promise<ReadableStreamReadResult<Uint8Array>> {\n    const byteLength = bufferOffset + byteCount;\n    await tryFillTo(byteLength);\n    const maxBytesToRead = Math.min(bufferLength - bufferOffset, byteCount);\n    if (maxBytesToRead === 0) {\n      return { done: true };\n    }\n    const bytes = buffer.slice(bufferOffset, bufferOffset + maxBytesToRead);\n    bufferOffset += maxBytesToRead;\n    return { done: false, value: bytes };\n  }\n\n  function releaseLock() {\n    reader.releaseLock();\n  }\n\n  return {\n    readLine,\n    read,\n    releaseLock,\n  };\n}\n","import { bytesToInteger, integerToBytes } from \"@aicacia/hash\";\nimport {\n\tbufferedWritableStream,\n\tDEFAULT_MAX_MESSAGE_SIZE,\n\trandomUInt32,\n\twritableStreamFromChannel,\n} from \"./utils\";\nimport {\n\tHTTPRequest,\n\tparseHTTPResponse,\n\twriteHTTPRequestOrResponse,\n} from \"./HTTP\";\n\ntype Fetch = typeof fetch;\n\nexport type WebRTCFetch = Fetch & {\n\tdestroy(): void;\n};\n\ntype WebRTCConnection = {\n\tidBytes: Uint8Array;\n\tstream: TransformStream;\n\twriter: WritableStreamDefaultWriter<Uint8Array>;\n};\n\nexport function createWebRTCFetch(channel: RTCDataChannel): WebRTCFetch {\n\tconst connections = new Map<number, WebRTCConnection>();\n\n\tfunction createWebRTCConnection() {\n\t\tlet connectionId = randomUInt32();\n\t\twhile (connections.has(connectionId)) {\n\t\t\tconnectionId = randomUInt32();\n\t\t}\n\t\tconst idBytes = integerToBytes(new Uint8Array(4), connectionId);\n\t\tconst stream = new TransformStream();\n\t\tconst connection = {\n\t\t\tidBytes,\n\t\t\tstream,\n\t\t\twriter: stream.writable.getWriter(),\n\t\t};\n\t\tconnections.set(connectionId, connection);\n\t\treturn connection;\n\t}\n\n\tasync function onData(connectionId: number, chunk: Uint8Array) {\n\t\tconst connection = connections.get(connectionId);\n\t\tif (!connection) {\n\t\t\tthrow new Error(`No connection found for id: ${connectionId}`);\n\t\t}\n\t\tawait connection.writer.write(chunk);\n\t}\n\n\tasync function onMessage(event: MessageEvent) {\n\t\tconst chunk = new Uint8Array(event.data);\n\t\tconst connectionId = bytesToInteger(chunk);\n\t\tawait onData(connectionId, chunk.slice(4));\n\t}\n\tchannel.addEventListener(\"message\", onMessage);\n\n\tconst fetch: WebRTCFetch = (input, init) => {\n\t\treturn new Promise<Response>((resolve, reject) => {\n\t\t\tconst request = new HTTPRequest(input, init);\n\t\t\tconst connection = createWebRTCConnection();\n\t\t\tconst writableStream = bufferedWritableStream(\n\t\t\t\twritableStreamFromChannel(\n\t\t\t\t\tchannel,\n\t\t\t\t\tconnection.idBytes,\n\t\t\t\t\tDEFAULT_MAX_MESSAGE_SIZE,\n\t\t\t\t),\n\t\t\t);\n\t\t\twriteHTTPRequestOrResponse(writableStream, request)\n\t\t\t\t.then(() =>\n\t\t\t\t\tparseHTTPResponse(connection.stream.readable.getReader()).then(\n\t\t\t\t\t\tresolve,\n\t\t\t\t\t),\n\t\t\t\t)\n\t\t\t\t.catch(reject);\n\t\t});\n\t};\n\n\tfetch.destroy = () => channel.removeEventListener(\"message\", onMessage);\n\n\treturn fetch;\n}\n","import { bytesToInteger, integerToBytes } from \"@aicacia/hash\";\nimport { parseHTTPRequest, writeHTTPRequestOrResponse } from \"./HTTP\";\nimport {\n\tbufferedWritableStream,\n\tDEFAULT_MAX_MESSAGE_SIZE,\n\twritableStreamFromChannel,\n} from \"./utils\";\n\ninterface WebRTCConnection {\n\tstream: TransformStream<Uint8Array, Uint8Array>;\n\twriter: WritableStreamDefaultWriter<Uint8Array>;\n}\n\nfunction createWebRTCConnection(): WebRTCConnection {\n\tconst stream = new TransformStream<Uint8Array>();\n\treturn {\n\t\tstream,\n\t\twriter: stream.writable.getWriter(),\n\t};\n}\n\nexport function createWebRTCServer(\n\tchannel: RTCDataChannel,\n\thandler: (request: Request) => Promise<Response> | Response,\n) {\n\tconst connections = new Map<number, WebRTCConnection>();\n\n\tasync function handle(connectionId: number, connection: WebRTCConnection) {\n\t\tconst request = await parseHTTPRequest(\n\t\t\tconnection.stream.readable.getReader(),\n\t\t);\n\t\tconst response = await handler(request);\n\t\tconst writableStream = bufferedWritableStream(\n\t\t\twritableStreamFromChannel(\n\t\t\t\tchannel,\n\t\t\t\tintegerToBytes(new Uint8Array(4), connectionId),\n\t\t\t\tDEFAULT_MAX_MESSAGE_SIZE,\n\t\t\t),\n\t\t);\n\t\tawait writeHTTPRequestOrResponse(writableStream, response);\n\t}\n\n\tasync function onData(connectionId: number, chunk: Uint8Array) {\n\t\tlet connection = connections.get(connectionId);\n\t\tif (!connection) {\n\t\t\tconnection = createWebRTCConnection();\n\t\t\tconnections.set(connectionId, connection);\n\t\t\thandle(connectionId, connection);\n\t\t}\n\t\tawait connection.writer.write(chunk);\n\t}\n\n\tasync function onMessage(event: MessageEvent) {\n\t\tconst chunk = new Uint8Array(event.data);\n\t\tconst connectionId = bytesToInteger(chunk);\n\t\tawait onData(connectionId, chunk.slice(4));\n\t}\n\tchannel.addEventListener(\"message\", onMessage);\n\n\treturn () => {\n\t\tchannel.removeEventListener(\"message\", onMessage);\n\t};\n}\n"],"names":["DEFAULT_BUFFER_SIZE","concatUint8Array","a","b","bytes","Uint8Array","byteLength","set","writeToUint8Array","buffer","offset","chunk","newBuffer","randomUInt32","Math","random","MAX_INT","writableStreamFromChannel","channel","idBytes","maxChannelMessageSize","WritableStream","write","send","length","min","slice","bufferedWritableStream","writableStream","bufferSize","bufferOffset","writer","getWriter","async","flush","close","HEADER_REGEX","HEADER_CONTINUE_REGEX","REQUEST_REGEX","RESPONSE_REGEX","NEWLINE","charCodeAt","RETURN","TEXT_ENCODER","TextEncoder","TEXT_DECODER","TextDecoder","HTTPRequest","Request","constructor","input","init","headersInit","headers","super","Headers","Object","defineProperty","this","value","writable","parseHTTPRequest","reader","textReader","createTextReader","method","url","done","startLine","readLine","Error","match","exec","readRequestStartLine","chunked","contentLength","readHeaders","body","streamBody","mode","credentials","duplex","parseHTTPResponse","statusCode","statusText","readResponseStartLine","Response","status","writeHTTPRequestOrResponse","requestOrResponse","request","response","encode","Number","parseInt","get","toLowerCase","key","entries","read","result","releaseLock","readAll","getReader","pipeTo","line","continueMatch","append","stream","TransformStream","chunkSize","bytesLeft","streamBodyFromReaderToWriter","readable","bufferLength","doneReading","tryFillTo","index","hasData","decode","byteCount","maxBytesToRead","createWebRTCFetch","connections","Map","onMessage","event","data","connectionId","bytesToInteger","connection","onData","addEventListener","fetch","Promise","resolve","reject","has","integerToBytes","createWebRTCConnection","then","catch","destroy","removeEventListener","createWebRTCServer","handler","handle"],"mappings":"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"}